/*
 * This file was generated by the Gradle 'init' task.
 *
 * This is a general purpose Gradle build.
 * Learn how to create Gradle builds at https://guides.gradle.org/creating-new-gradle-builds/
 */

import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent

buildscript {
    repositories {
        maven {
            url 'https://plugins.gradle.org/m2/'
        }
        maven {
            url 'https://repository.mulesoft.org/nexus/content/repositories/public/'
        }
        mavenCentral()
    }
    dependencies {
        classpath 'com.adarshr:gradle-test-logger-plugin:3.1.0'
        classpath 'gradle.plugin.net.ossindex:ossindex-gradle-plugin:0.4.11'
        classpath 'org.cyclonedx:cyclonedx-gradle-plugin:1.4.0'
    }
}

plugins {
    id 'base'
    id 'jacoco'
    id 'com.github.ben-manes.versions' version '0.39.0'
    id "org.sonarqube" version "3.3"
}

apply plugin: 'org.cyclonedx.bom'

cyclonedxBom {
    skipConfigs += ["api"]
}

if (hasProperty('buildScan')) {
    buildScan {
        termsOfServiceUrl = 'https://gradle.com/terms-of-service'
        termsOfServiceAgree = 'yes'
    }
}

ext {
    // Defines the minimum BDeploy version when upgrading to "this" version. This is checked on servers which support this property prior to performing the update.
    minSourceServerVersion = "2.0.0"

    // Defines the path to a WINDOWS JDK, to be able to build windows dist packages on linux
    win64jdk = readJdk("win64jdk")
    // Defines the path to a LINUX JDK, to be able to build linux dist packages on windows
    linux64jdk = readJdk("linux64jdk")
    // Defines the path to a WINDOWS JDK, to be able to build windows dist packages on linux
    mac64jdk = readJdk("mac64jdk")

    // build SNAPSHOT replacement where needed.
    buildDate = new Date().format('yyyyMMddHHmm')

    // all java projects. these projects are pre-configured by the root project with a ton of helpers.
    actualSubprojects = subprojects - [ project(':test-data'), project(':doc') ];
}

allprojects {
    version = new File(rootProject.projectDir, "/bdeploy.version").text

    repositories {
        mavenCentral()
    }
}

task printVersion {
    doLast {
        println version
    }
}

task setVersion {
    doFirst {
        if(!project.hasProperty('targetVersion')) {
            throw new RuntimeException("Need to set property targetVersion");
        }
    }
    doLast {
        new File(projectDir, "/bdeploy.version").text = project.getProperty('targetVersion');
    }
}

configure(actualSubprojects) {
    apply plugin: 'java'
    apply plugin: 'java-test-fixtures'
    apply plugin: 'jacoco'
    apply plugin: 'com.adarshr.test-logger'
    apply plugin: 'eclipse'
    apply plugin: "net.ossindex.audit"

    compileJava.options.encoding = 'UTF-8'
    compileTestJava.options.encoding = 'UTF-8'
    compileTestFixturesJava.options.encoding = 'UTF-8'

    java {
        // enabled by default in gradle 7.0 - breaks executing anything from eclipse, but not from the CLI
        modularity.inferModulePath = false
    }
	
	eclipse {
		classpath {
			downloadSources = true
		}
	}

    eclipse.project {
        natures 'org.eclipse.xtext.ui.shared.xtextNature'
        buildCommand 'org.eclipse.xtext.ui.shared.xtextBuilder'
    }

    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17

    configurations {
        commonTestDeps
        testFixturesImplementation {
            extendsFrom commonTestDeps
        }
        testImplementation {
            extendsFrom commonTestDeps
        }
    }

    dependencies {
        commonTestDeps 'org.junit.jupiter:junit-jupiter-api:5.8.2',
                       'org.junit.jupiter:junit-jupiter-params:5.8.2',
                       'org.hamcrest:hamcrest-core:2.2'
        testRuntimeOnly    'org.junit.jupiter:junit-jupiter-engine:5.8.2'
    }

    eclipseJdt.doLast {
        File f = file('.settings/org.eclipse.core.resources.prefs')
        f.write('eclipse.preferences.version=1\n')
        f.append('encoding/<project>=UTF-8')
    }

    audit {
        rateLimitAsError = false
        failOnError = false
        ignore = [
            'org.dom4j:dom4j:2.1.0' // introduced by spotbugs, which is not part of the distribution
        ]
    }

    jacocoTestReport {
        mustRunAfter "test"
        executionData fileTree(dir: "$buildDir/jacoco").matching { include '*.exec' }
    }

    testlogger {
        showStandardStreams true
        showFailedStandardStreams true

        if(project.hasProperty('verboseTest')) {
            showPassedStandardStreams true
            showSkippedStandardStreams true
            theme 'standard'
        } else {
            showPassedStandardStreams false
            showSkippedStandardStreams false
            theme 'mocha-parallel'
        }

        slowThreshold 6000
        showFullStackTraces true
    }

    test {
        useJUnitPlatform()
        if(!project.hasProperty('verboseTest')) {
            maxParallelForks = Runtime.runtime.availableProcessors().intdiv(2) ?: 1
        }
        maxHeapSize = "2g"
        testLogging {
            reports.html.enabled = false
        }

        if(project.hasProperty("test.hive.override")) {
            systemProperty "test.hive.override", project.getProperty("test.hive.override")
        }
        if(project.hasProperty("test.manifestName.override")) {
            systemProperty "test.manifestName.override", project.getProperty("test.manifestName.override")
        }

        rootProject.updateJavaPath(test)
    }

	task sourcesJar(type: Jar) {
        classifier = 'sources'
        from sourceSets.main.allJava
    }

    task javadocJar(type: Jar) {
        classifier = 'javadoc'
        from javadoc.destinationDir

        dependsOn javadoc
    }

    javadoc {
        options.encoding = 'UTF-8'
        options.addBooleanOption('html5', true)
        options.addStringOption('Xdoclint:-missing', '-quiet')
    }

    // custom JDT preferences, includes formatter, save actions, source compliance (!).
    eclipseJdt.doLast {
        file('.settings/org.eclipse.jdt.core.prefs').withWriter { writer ->
            // file is specific for sourceCompatibility which can be overruled in each project build.gradle
            writer << file("${rootDir}/templates/org.eclipse.jdt.core.prefs-${sourceCompatibility}").text
        }
        file('.settings/org.eclipse.jdt.ui.prefs').withWriter { writer ->
            writer << file("${rootDir}/templates/org.eclipse.jdt.ui.prefs").text
        }
    }

    task cleanCustomEclipseJdt(type: Delete) {
        delete ".settings/org.eclipse.jdt.ui.prefs"
    }

    cleanEclipseJdt.finalizedBy cleanCustomEclipseJdt
}

configure([project(':minion'), project(':launcher')]) {
    task genVersionProperties() {
        outputs.upToDateWhen { false }
        outputs.file "$buildDir/resources/main/version.properties"
        doLast {
            file("$buildDir/resources/main").mkdirs()
            file("$buildDir/resources/main/version.properties").withWriter { w ->
                def p = new Properties()
                p['project'] = project.name
                p['snapshot'] = version.contains('SNAPSHOT') ? 'true' : 'false'
                p['version'] = version.replaceAll('SNAPSHOT', rootProject.ext.buildDate)
                p['minSourceVersion'] = minSourceServerVersion
                p.store w, null
            }
        }
    }

    task genLinux64VersionProperties() {
        dependsOn genVersionProperties
        outputs.upToDateWhen { false }
        outputs.file "$buildDir/resources/linux64/version.properties"
        doLast {
            file("$buildDir/resources/linux64").mkdirs()
            file("$buildDir/resources/linux64/version.properties").withWriter { w ->
                def p = new Properties()
                file("$buildDir/resources/main/version.properties").withInputStream { is -> p.load is }
                p['os'] = 'LINUX' // literal of OperatingSystem
                p.store w, null
            }
        }
    }

    task genWin64VersionProperties() {
        dependsOn genVersionProperties
        outputs.upToDateWhen { false }
        outputs.file "$buildDir/resources/win64/version.properties"
        doLast {
            file("$buildDir/resources/win64").mkdirs()
            file("$buildDir/resources/win64/version.properties").withWriter { w ->
                def p = new Properties()
                file("$buildDir/resources/main/version.properties").withInputStream { is -> p.load is }
                p['os'] = 'WINDOWS' // literal of OperatingSystem
                p.store w, null
            }
        }
    }

    task genMac64VersionProperties() {
        dependsOn genVersionProperties
        outputs.upToDateWhen { false }
        outputs.file "$buildDir/resources/mac64/version.properties"
        doLast {
            file("$buildDir/resources/mac64").mkdirs()
            file("$buildDir/resources/mac64/version.properties").withWriter { w ->
                def p = new Properties()
                file("$buildDir/resources/main/version.properties").withInputStream { is -> p.load is }
                p['os'] = 'MACOS' // literal of OperatingSystem
                p.store w, null
            }
        }
    }


    processResources.dependsOn genLinux64VersionProperties
    processResources.dependsOn genWin64VersionProperties
    processResources.dependsOn genMac64VersionProperties
}

def void addMultiPlatformDistBuild(Project prj) {
    prj.startScripts {
        inputs.dir "${rootProject.projectDir}/templates/scripts"

        // copied from https://github.com/gradle/gradle/tree/master/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins
        unixStartScriptGenerator.template = resources.text.fromFile("${rootProject.projectDir}/templates/scripts/unixUpdateStartScript.txt")
        windowsStartScriptGenerator.template = resources.text.fromFile("${rootProject.projectDir}/templates/scripts/windowsUpdateStartScript.txt")

        if(prj.ext.has('scriptDefVmArgs')) {
            defaultJvmOpts = prj.ext.get('scriptDefVmArgs')
        }
    }

    prj.distributions {
        linux64 {
            contents {
                with prj.distributions.main.getContents()
                from rootProject.jlinkLinux64.outputs
                from prj.genLinux64VersionProperties.outputs
            }
        }

        win64 {
            contents {
                with prj.distributions.main.getContents()
                from rootProject.jlinkWin64.outputs
                from prj.genWin64VersionProperties.outputs
            }
        }

        mac64 {
            contents {
                with prj.distributions.main.getContents()
                from rootProject.jlinkMac64.outputs
                from prj.genMac64VersionProperties.outputs
            }
        }
    }

    // don't build the ZIP dist without any JVM
    prj.distZip.enabled = false

    // no tar files at all, please
    prj.distTar.enabled = false
    prj.linux64DistTar.enabled = false
    prj.win64DistTar.enabled = false
    prj.mac64DistTar.enabled = false

    if (org.gradle.internal.os.OperatingSystem.current().isLinux()) {
        // need special JDK for win64 as module input dir
        prj.build.dependsOn prj.linux64DistZip
        prj.installDist.dependsOn prj.installLinux64Dist
        if(!hasWinJdk()) {
            prj.win64DistZip.enabled = false
        }
        if(!hasMacJdk()) {
            prj.mac64DistZip.enabled = false
        }
    } else if(org.gradle.internal.os.OperatingSystem.current().isWindows()) {
        // need special JDK for linux64 as module input dir
        prj.build.dependsOn prj.win64DistZip
        prj.installDist.dependsOn prj.installWin64Dist
        if(!hasLinuxJdk()) {
            prj.linux64DistZip.enabled = false
        }
        if(!hasMacJdk()) {
            prj.mac64DistZip.enabled = false
        }
    } else if(org.gradle.internal.os.OperatingSystem.current().isMacOsX()) {
        // need special JDK for linux64 as module input dir
        prj.build.dependsOn prj.mac64DistZip
        prj.installDist.dependsOn prj.installMac64Dist
        if(!hasLinuxJdk()) {
            prj.linux64DistZip.enabled = false
        }
        if(!hasWinJdk()) {
            prj.win64DistZip.enabled = false
        }
    }

    prj.installLinux64Dist.doFirst {
        delete "$destinationDir"
    }
    prj.installWin64Dist.doFirst {
        delete "$destinationDir"
    }
    prj.installMac64Dist.doFirst {
        delete "$destinationDir"
    }

}

task testReport(type: TestReport) {
    destinationDir = file("$buildDir/reports/tests")
    // Include the results from the `test` task in all subprojects
    reportOn actualSubprojects*.test
}

task genJavaDoc(type: Javadoc) {
    source = actualSubprojects*.sourceSets.main.allJava
    destinationDir = reporting.file("javadoc")
    classpath = files(actualSubprojects*.sourceSets.main.compileClasspath)
    options.encoding = 'UTF-8'
    options.addBooleanOption('html5', true)
    options.addStringOption('Xdoclint:-missing', '-quiet')
}

build.finalizedBy genJavaDoc

/*gradle.taskGraph.whenReady {taskGraph ->
    println "Found task graph: " + taskGraph
    println "Found " + taskGraph.allTasks.size() + " tasks."
    taskGraph.allTasks.forEach { task ->
        println task
        task.dependsOn.forEach { dep ->
            println "  - " + dep
        }
    }
}*/

def isNonStable = { String version ->
  // -jre for guava
  def stableKeyword = ['RELEASE', 'FINAL', 'GA', '-JRE'].any { it -> version.toUpperCase().contains(it) }
  def regex = /^[0-9,.v-]+(-r)?$/
  return !stableKeyword && !(version ==~ regex)
}

dependencyUpdates {
    rejectVersionIf {
        isNonStable(it.candidate.version)
    }
}

private boolean hasWinJdk() {
    return file("$win64jdk/bin/java.exe").exists();
}

private boolean hasLinuxJdk() {
    return file("$linux64jdk/lib/libjava.so").exists();
}

private boolean hasMacJdk() {
    return file("$mac64jdk/lib/libjava.dylib").exists();
}

private String readJdk(String which) {
    def v = System.getProperty(which)
    if(v != null) {
        println("Using " + which + " from " + v);
        return v;
    }
    return System.getProperty("java.home")
}

private void updateJavaPath(ProcessForkOptions options) {
    if(org.gradle.internal.os.OperatingSystem.current().isLinux()) {
        options.executable = "${rootProject.buildDir}/jlink/linux64/jre/bin/java"
    } else if(org.gradle.internal.os.OperatingSystem.current().isWindows()) {
        options.executable = "${rootProject.buildDir}/jlink/win64/jre/bin/java.exe"
    } else if(org.gradle.internal.os.OperatingSystem.current().isMacOsX()) {
        options.executable = "${rootProject.buildDir}/jlink/mac64/jre/bin/java"
    }
}

ext.configureJlink = { task, String modHome, String outDir ->
    configure(task) {
        outputs.dir "$outDir"

        def linkExec
        if(org.gradle.internal.os.OperatingSystem.current().isLinux()) {
            linkExec = [ "$linux64jdk/bin/jlink", "--module-path", "$modHome/jmods:mlib" ]
        } else if(org.gradle.internal.os.OperatingSystem.current().isMacOsX()) {
            linkExec = [ "$mac64jdk/bin/jlink", "--module-path", "$modHome/jmods:mlib" ]
        } else if(org.gradle.internal.os.OperatingSystem.current().isWindows()) {
            linkExec = [ "$win64jdk\\bin\\jlink.exe", "--module-path", "$modHome\\jmods;mlib" ]
        }

        // find required modules with this command:
        // $JAVA_HOME/bin/jdeps -summary *.jar | awk '{ print $3 }' | sort -u
        commandLine ( linkExec + [
            "--output", "$outDir/jre",
            "--compress=2", "--no-header-files", "--no-man-pages",
            "--add-modules",
            "java.base,java.compiler,java.datatransfer,java.desktop,java.instrument,java.logging,java.management,java.naming,java.sql,java.xml,java.rmi,jdk.crypto.ec,jdk.jdwp.agent,jdk.jdi,jdk.zipfs,jdk.jcmd,jdk.management"
        ])

        doFirst {
            delete "$outDir"
        }
    }
}

task jlinkLinux64(type:Exec) { t ->
    configureJlink(t, "$linux64jdk", "$buildDir/jlink/linux64")
    doFirst {
        if (!hasLinuxJdk()) {
            throw new InvalidUserDataException("$linux64jdk does not seem to be a linux JDK, please set -Plinux64jdk=c:/path/to/jdk")
        }
    }
}

task jlinkWin64(type:Exec) { t ->
    configureJlink(t, "$win64jdk", "$buildDir/jlink/win64")
    doFirst {
        if (!hasWinJdk()) {
            throw new InvalidUserDataException("$win64jdk does not seem to be a windows JDK, please set -Pwin64jdk=/path/to/jdk")
        }
    }

    doLast {
        String base = new File("$buildDir/jlink/win64/jre").getPath();
        fileTree("$buildDir/jlink/win64/jre").matching {
            include "**/*.exe"
            include "**/*.dll"
        }.each {
            String rel = it.getPath().substring(base.length() + 1);
            File src = new File("$win64jdk", rel);
            
            if(src.exists()) {
                java.nio.file.Files.copy(src.toPath(), it.toPath(), java.nio.file.StandardCopyOption.REPLACE_EXISTING);
            }
        }
    }
}

task jlinkMac64(type:Exec) { t ->
    configureJlink(t, "$mac64jdk", "$buildDir/jlink/mac64")
    doFirst {
        if (!hasMacJdk()) {
            throw new InvalidUserDataException("$mac64jdk does not seem to be a windows JDK, please set -Pmac64jdk=/path/to/jdk")
        }
    }
}

task jlinkAny() {
    if(org.gradle.internal.os.OperatingSystem.current().isLinux()) {
        dependsOn jlinkLinux64
    } else if(org.gradle.internal.os.OperatingSystem.current().isWindows()) {
        dependsOn jlinkWin64
    } else if(org.gradle.internal.os.OperatingSystem.current().isMacOsX()) {
        dependsOn jlinkMac64
    }
}

actualSubprojects*.test {
    dependsOn rootProject.tasks["jlinkAny"]
}

task release() {
    doFirst {
        if(version.contains('SNAPSHOT')) {
            throw new RuntimeException("Cannot release a SNAPSHOT: " + version);
        }

        if(!hasWinJdk()) {
            throw new RuntimeException("Cannot release without a WINDOWS JDK");
        }
        if(!hasLinuxJdk()) {
            throw new RuntimeException("Cannot release without a LINUX JDK");
        }
    }
}

evaluationDependsOnChildren()
task jacocoFullReport(type: org.gradle.testing.jacoco.tasks.JacocoReport) {
    dependsOn actualSubprojects*.test

    getAdditionalSourceDirs().from(files(actualSubprojects.sourceSets.main.allSource.srcDirs))
    getSourceDirectories().from(files(actualSubprojects.sourceSets.main.allSource.srcDirs))
    getClassDirectories().from(files(actualSubprojects.sourceSets.main.output))

    rootProject.getAllTasks(true).each { p, tasks ->
        if(p.name == 'interfaces' || p.name == 'launcher' || p.name == 'ui' || p.name == 'api' || p.name == 'logging') {
            return; // no tests run in there right now.
        }

        tasks.each {
            if(!it.enabled) {
                return;
            }
            def x = it.getExtensions().findByType(org.gradle.testing.jacoco.plugins.JacocoTaskExtension);
            if(x != null) {
                getExecutionData().from(x.destinationFile);
            }
        }
    }

    reports {
        xml.enabled = true
        xml.destination file("$buildDir/reports/jacoco/jacocoFullReport/jacocoFullReport.xml")
    }

    onlyIf = {
        true
    }
}

task test {
    dependsOn actualSubprojects*.test
    finalizedBy testReport
    finalizedBy jacocoFullReport
}

sonarqube {
    properties {
        property "sonar.projectKey", "bdeployteam_bdeploy"
        property "sonar.coverage.jacoco.xmlReportPaths", "$buildDir/reports/jacoco/jacocoFullReport/jacocoFullReport.xml"
        property "sonar.verbose", "true"
        property "sonar.host.url", "https://sonarcloud.io"
        property "sonar.organization", "bdeployteam"
    }
}

project.tasks["sonarqube"].dependsOn build
project.tasks["sonarqube"].dependsOn jacocoFullReport

build.dependsOn test

if (org.gradle.internal.os.OperatingSystem.current().isLinux()) {
    // need special JDK for win64 as module input dir
    if(!hasWinJdk()) {
        logger.warn("No windows JDK available, skipping windows distribution")
        jlinkWin64.enabled = false
    }
    if(!hasMacJdk()) {
        logger.warn("No MacOS JDK available, skipping MacOs distribution")
        jlinkMac64.enabled = false
    }
} else if (org.gradle.internal.os.OperatingSystem.current().isWindows()) {
    // need special JDK for linux64 as module input dir
    if(!hasLinuxJdk()) {
        logger.warn("No linux JDK available, skipping linux distribution")
        jlinkLinux64.enabled = false
    }
    if(!hasMacJdk()) {
        logger.warn("No MacOS JDK available, skipping MacOs distribution")
        jlinkMac64.enabled = false
    }
} else if (org.gradle.internal.os.OperatingSystem.current().isMacOsX()) {
    // need special JDK for linux64 as module input dir
    if(!hasLinuxJdk()) {
        logger.warn("No linux JDK available, skipping linux distribution")
        jlinkLinux64.enabled = false
    }
    if(!hasWinJdk()) {
        logger.warn("No windows JDK available, skipping windows distribution")
        jlinkWin64.enabled = false
    }
}

