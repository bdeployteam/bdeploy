/*
 * This file was generated by the Gradle 'init' task.
 *
 * This is a general purpose Gradle build.
 * Learn how to create Gradle builds at https://guides.gradle.org/creating-new-gradle-builds/
 */

import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent

buildscript {
    repositories {
        maven {
            url 'https://repository.mulesoft.org/nexus/content/repositories/public/'
        }
        mavenCentral()
        gradlePluginPortal()
    }
    dependencies {
        classpath 'com.adarshr:gradle-test-logger-plugin:4.0.0'
        classpath 'gradle.plugin.net.ossindex:ossindex-gradle-plugin:0.4.11'
        classpath 'org.kordamp.gradle:enforcer-gradle-plugin:0.14.0'
    }
}

plugins {
    id 'base'
    id 'jacoco'
    id 'com.github.ben-manes.versions' version '0.52.0'
    id "org.sonarqube" version "6.0.1.5171"
    id 'org.cyclonedx.bom' version '2.2.0'
}

cyclonedxBom {
    includeConfigs = ["runtimeClasspath"]
}

if (hasProperty('buildScan')) {
    buildScan {
        termsOfServiceUrl = 'https://gradle.com/terms-of-service'
        termsOfServiceAgree = 'yes'
    }
}

ext {
    // Defines the minimum BDeploy version when upgrading to "this" version. This is checked on servers which support this property prior to performing the update.
    minSourceServerVersion = "4.2.0"

    // CPU architecture of the running OS
    currentArch = System.getProperty("os.arch")

    // Defines the path to a WINDOWS JDK, to be able to build windows dist packages on linux
    winX64jdk = readJdk("win-x64jdk")
    // Defines the path to a LINUX JDK, to be able to build linux dist packages on windows
    linuxX64jdk = readJdk("linux-x64jdk")
    // Defines the path to a LINUX AARCH64 JSK, to be able to build arm packages
    linuxAarch64jdk = readJdk("linux-aarch64jdk")

    // build SNAPSHOT replacement where needed.
    buildDate = new Date().format('yyyyMMddHHmm')

    // all java projects. these projects are pre-configured by the root project with a ton of helpers.
    actualSubprojects = subprojects - [ project(':test-data'), project(':doc') ];
}

allprojects {
    version = new File(rootProject.projectDir, "/bdeploy.version").text
    group = 'io.bdeploy'

    repositories {
        mavenCentral()
    }
}

task printVersion {
    doLast {
        println version
    }
}

task setVersion {
    doFirst {
        if(!project.hasProperty('targetVersion')) {
            throw new RuntimeException("Need to set property targetVersion");
        }
    }
    doLast {
        new File(projectDir, "/bdeploy.version").text = project.getProperty('targetVersion');
    }
}

configure(actualSubprojects) {
    apply plugin: 'java'
    apply plugin: 'java-test-fixtures'
    apply plugin: 'jacoco'
    apply plugin: 'com.adarshr.test-logger'
    apply plugin: 'eclipse'
    apply plugin: 'net.ossindex.audit'
    apply plugin: 'org.kordamp.gradle.project-enforcer'

    compileJava.options.encoding = 'UTF-8'
    compileTestJava.options.encoding = 'UTF-8'
    compileTestFixturesJava.options.encoding = 'UTF-8'

    java {
        // enabled by default in gradle 7.0 - breaks executing anything from eclipse, but not from the CLI
        modularity.inferModulePath = false
    }

	eclipse {
		classpath {
			downloadSources = true
		}
	}

    eclipse.project {
        natures 'org.eclipse.xtext.ui.shared.xtextNature'
        buildCommand 'org.eclipse.xtext.ui.shared.xtextBuilder'
    }

    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21

    configurations {
        commonTestDeps
        testFixturesImplementation {
            extendsFrom commonTestDeps
        }
        testImplementation {
            extendsFrom commonTestDeps
        }
    }

    dependencies {
        commonTestDeps platform('org.junit:junit-bom:5.12.1')
        commonTestDeps 'org.junit.jupiter:junit-jupiter'
        commonTestDeps 'org.hamcrest:hamcrest-core:3.0'
        testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    }

    eclipseJdt.doLast {
        File f = file('.settings/org.eclipse.core.resources.prefs')
        f.write('eclipse.preferences.version=1\n')
        f.append('encoding/<project>=UTF-8')
    }

    audit {
        rateLimitAsError = false
        failOnError = false
        ignore = [
            'org.dom4j:dom4j:2.1.0' // introduced by spotbugs, which is not part of the distribution
        ]
    }

    jacocoTestReport {
        mustRunAfter "test"
        executionData fileTree(dir: "$buildDir/jacoco").matching { include '*.exec' }
    }

    testlogger {
        showStandardStreams true
        showFailedStandardStreams true

        if(project.hasProperty('verboseTest')) {
            showPassedStandardStreams true
            showSkippedStandardStreams true
            theme 'standard'
        } else {
            showPassedStandardStreams false
            showSkippedStandardStreams false
            theme 'mocha-parallel'
        }

        slowThreshold 6000
        showFullStackTraces true
    }

    test {
        useJUnitPlatform()
        if(!project.hasProperty('verboseTest')) {
            maxParallelForks = Runtime.runtime.availableProcessors().intdiv(2) ?: 1
        }
        maxHeapSize = "2g"
        testLogging {
            reports.html.required = false
        }

        if(project.hasProperty("test.hive.override")) {
            systemProperty "test.hive.override", project.getProperty("test.hive.override")
        }
        if(project.hasProperty("test.manifestName.override")) {
            systemProperty "test.manifestName.override", project.getProperty("test.manifestName.override")
        }

        rootProject.updateJavaPath(test)
    }

	task sourcesJar(type: Jar) {
        archiveClassifier = 'sources'
        from sourceSets.main.allJava
    }

    task javadocJar(type: Jar) {
        archiveClassifier = 'javadoc'
        from javadoc.destinationDir

        dependsOn javadoc
    }

    javadoc {
        options.encoding = 'UTF-8'
        options.addBooleanOption('html5', true)
        options.addStringOption('Xdoclint:-missing', '-quiet')
    }

    // custom JDT preferences, includes formatter, save actions, source compliance (!).
    eclipseJdt.doLast {
        file('.settings/org.eclipse.jdt.core.prefs').withWriter { writer ->
            // file is specific for sourceCompatibility which can be overruled in each project build.gradle
            writer << file("${rootDir}/templates/org.eclipse.jdt.core.prefs-${sourceCompatibility}").text
        }
        file('.settings/org.eclipse.jdt.ui.prefs').withWriter { writer ->
            writer << file("${rootDir}/templates/org.eclipse.jdt.ui.prefs").text
        }
    }

    task cleanCustomEclipseJdt(type: Delete) {
        delete ".settings/org.eclipse.jdt.ui.prefs"
    }

    cleanEclipseJdt.finalizedBy cleanCustomEclipseJdt
}

configure([project(':minion'), project(':launcher')]) {
    task genVersionProperties() {
        outputs.upToDateWhen { false }
        outputs.file "$buildDir/resources/main/version.properties"
        doLast {
            file("$buildDir/resources/main").mkdirs()
            file("$buildDir/resources/main/version.properties").withWriter { w ->
                def p = new Properties()
                p['project'] = project.name
                p['snapshot'] = version.contains('SNAPSHOT') ? 'true' : 'false'
                p['version'] = version.replaceAll('SNAPSHOT', rootProject.ext.buildDate)
                p['minSourceVersion'] = minSourceServerVersion
                p.store w, null
            }
        }
    }

    task genLinuxX64VersionProperties() {
        dependsOn genVersionProperties
        outputs.upToDateWhen { false }
        outputs.file "$buildDir/resources/linuxX64/version.properties"
        doLast {
            file("$buildDir/resources/linuxX64").mkdirs()
            file("$buildDir/resources/linuxX64/version.properties").withWriter { w ->
                def p = new Properties()
                file("$buildDir/resources/main/version.properties").withInputStream { is -> p.load is }
                p['os'] = 'LINUX' // literal of OperatingSystem
                p.store w, null
            }
        }
    }

    task genLinuxAarch64VersionProperties() {
        dependsOn genVersionProperties
        outputs.upToDateWhen { false }
        outputs.file "$buildDir/resources/linuxAarch64/version.properties"
        doLast {
            file("$buildDir/resources/linuxAarch64").mkdirs()
            file("$buildDir/resources/linuxAarch64/version.properties").withWriter { w ->
                def p = new Properties()
                file("$buildDir/resources/main/version.properties").withInputStream { is -> p.load is }
                p['os'] = 'LINUX_AARCH64' // literal of OperatingSystem
                p.store w, null
            }
        }
    }

    task genWinX64VersionProperties() {
        dependsOn genVersionProperties
        outputs.upToDateWhen { false }
        outputs.file "$buildDir/resources/winX64/version.properties"
        doLast {
            file("$buildDir/resources/winX64").mkdirs()
            file("$buildDir/resources/winX64/version.properties").withWriter { w ->
                def p = new Properties()
                file("$buildDir/resources/main/version.properties").withInputStream { is -> p.load is }
                p['os'] = 'WINDOWS' // literal of OperatingSystem
                p.store w, null
            }
        }
    }

    processResources.dependsOn genLinuxX64VersionProperties
    processResources.dependsOn genLinuxAarch64VersionProperties
    processResources.dependsOn genWinX64VersionProperties
}

def void addMultiPlatformDistBuild(Project prj) {
    prj.startScripts {
        inputs.dir "${rootProject.projectDir}/templates/scripts"

        // copied from https://github.com/gradle/gradle/tree/master/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins
        unixStartScriptGenerator.template = resources.text.fromFile("${rootProject.projectDir}/templates/scripts/unixUpdateStartScript.txt")
        windowsStartScriptGenerator.template = resources.text.fromFile("${rootProject.projectDir}/templates/scripts/windowsUpdateStartScript.txt")

        if(prj.ext.has('scriptDefVmArgs')) {
            defaultJvmOpts = prj.ext.get('scriptDefVmArgs')
        }
    }

    prj.distributions {
        linuxX64 {
            contents {
                with prj.distributions.main.getContents()
                from rootProject.jlinkLinuxX64.outputs
                from prj.genLinuxX64VersionProperties.outputs
            }
        }

        linuxAarch64 {
            contents {
                with prj.distributions.main.getContents()
                from rootProject.jlinkLinuxAarch64.outputs
                from prj.genLinuxAarch64VersionProperties.outputs
            }
        }

        winX64 {
            contents {
                with prj.distributions.main.getContents()
                from rootProject.jlinkWinX64.outputs
                from prj.genWinX64VersionProperties.outputs
            }
        }
    }

    // don't build the ZIP dist without any JVM
    prj.distZip.enabled = false

    // no tar files at all, please
    prj.distTar.enabled = false
    prj.linuxX64DistTar.enabled = false
    prj.linuxAarch64DistTar.enabled = false
    prj.winX64DistTar.enabled = false

    if (org.gradle.internal.os.OperatingSystem.current().isLinux()) {
        if(isAarch64()) {
            prj.build.dependsOn prj.linuxAarch64DistZip
            prj.installDist.dependsOn prj.installLinuxAarch64Dist
            if(!hasWinX64Jdk()) {
                prj.winX64DistZip.enabled = false
            }
            if(!hasLinuxX64Jdk()) {
                prj.linuxX64DistZip.enabled = false
            }
        } else {
            prj.build.dependsOn prj.linuxX64DistZip
            prj.installDist.dependsOn prj.installLinuxX64Dist
            if(!hasWinX64Jdk()) {
                prj.winX64DistZip.enabled = false
            }
            if(!hasLinuxAarch64Jdk()) {
                prj.linuxAarch64DistZip.enabled = false
            }
        }
    } else if(org.gradle.internal.os.OperatingSystem.current().isWindows()) {
        prj.build.dependsOn prj.winX64DistZip
        prj.installDist.dependsOn prj.installWinX64Dist
        if(!hasLinuxX64Jdk()) {
            prj.linuxX64DistZip.enabled = false
        }
        if(!hasLinuxAarch64Jdk()) {
            prj.linuxAarch64DistZip.enabled = false
        }
    }

    prj.installLinuxX64Dist.doFirst {
        delete "$destinationDir"
    }
    prj.installLinuxAarch64Dist.doFirst {
        delete "$destinationDir"
    }
    prj.installWinX64Dist.doFirst {
        delete "$destinationDir"
    }

}

task testReport(type: TestReport) {
    destinationDir = file("$buildDir/reports/tests")
    // Include the results from the `test` task in all subprojects
    reportOn actualSubprojects*.test
}

task genJavaDoc(type: Javadoc) {
    source = actualSubprojects*.sourceSets.main.allJava
    destinationDir = reporting.file("javadoc")
    classpath = files(actualSubprojects*.sourceSets.main.compileClasspath)
    options.encoding = 'UTF-8'
    options.addBooleanOption('html5', true)
    options.addStringOption('Xdoclint:-missing', '-quiet')
}

build.finalizedBy genJavaDoc

/*gradle.taskGraph.whenReady {taskGraph ->
    println "Found task graph: " + taskGraph
    println "Found " + taskGraph.allTasks.size() + " tasks."
    taskGraph.allTasks.forEach { task ->
        println task
        task.dependsOn.forEach { dep ->
            println "  - " + dep
        }
    }
}*/

def isNonStable = { String version ->
  // -jre for guava
  def stableKeyword = ['RELEASE', 'FINAL', 'GA', '-JRE'].any { it -> version.toUpperCase().contains(it) }
  def regex = /^[0-9,.v-]+(-r)?$/
  return !stableKeyword && !(version ==~ regex)
}

dependencyUpdates {
    rejectVersionIf {
        isNonStable(it.candidate.version)
    }
}

private boolean hasWinX64Jdk() {
    return file("$winX64jdk/bin/java.exe").exists();
}

private boolean hasLinuxX64Jdk() {
    return file("$linuxX64jdk/lib/libjava.so").exists();
}

public boolean hasLinuxAarch64Jdk() {
    return file("$linuxAarch64jdk/lib/libjava.so").exists();
}

private String readJdk(String which) {
    def v = System.getProperty(which)
    if(v != null) {
        println("Using " + which + " from " + v);
        return v;
    }

    // only return running jdk on the correct platform.
    if(which.equals("win-x64jdk") && org.gradle.internal.os.OperatingSystem.current().isLinux()) {
        return null;
    }
    if(which.equals("linux-x64jdk") && (!org.gradle.internal.os.OperatingSystem.current().isLinux() || isAarch64())) {
        return null;
    }
    if(which.equals("linux-aarch64jdk") && (!org.gradle.internal.os.OperatingSystem.current().isLinux() || !isAarch64())) {
        return null;
    }

    // we're native here, so return the running java
    return System.getProperty("java.home")
}


private boolean isAarch64() {
    return currentArch.equalsIgnoreCase("aarch64");
}

private void updateJavaPath(ProcessForkOptions options) {
    if(org.gradle.internal.os.OperatingSystem.current().isLinux()) {
        if(isAarch64()) {
            options.executable = "${rootProject.buildDir}/jlink/linuxAarch64/jre/bin/java"
        } else {
            options.executable = "${rootProject.buildDir}/jlink/linuxX64/jre/bin/java"
        }
    } else if(org.gradle.internal.os.OperatingSystem.current().isWindows()) {
        options.executable = "${rootProject.buildDir}/jlink/winX64/jre/bin/java.exe"
    }
}

ext.configureJlink = { task, String modHome, String outDir ->
    configure(task) {
        outputs.dir "$outDir"

        def linkExec
        if(org.gradle.internal.os.OperatingSystem.current().isLinux()) {
            if(isAarch64()) {
                linkExec = [ "$linuxAarch64jdk/bin/jlink", "--module-path", "$modHome/jmods:mlib" ]
            } else {
                linkExec = [ "$linuxX64jdk/bin/jlink", "--module-path", "$modHome/jmods:mlib" ]
            }
        } else if(org.gradle.internal.os.OperatingSystem.current().isWindows()) {
            linkExec = [ "$winX64jdk\\bin\\jlink.exe", "--module-path", "$modHome\\jmods;mlib" ]
        }

        // find required modules with this command:
        // $JAVA_HOME/bin/jdeps -summary *.jar | awk '{ print $3 }' | sort -u
        commandLine ( linkExec + [
            "--output", "$outDir/jre",
            "--compress=zip-9", "--no-header-files", "--no-man-pages",
            "--add-modules",
            "java.base,java.compiler,java.datatransfer,java.desktop,java.instrument,java.logging,java.management,java.naming,java.sql,java.xml,java.rmi,jdk.crypto.ec,jdk.jdwp.agent,jdk.jdi,jdk.zipfs,jdk.jcmd,jdk.management"
        ])

        doFirst {
            delete "$outDir"
        }
    }
}

task jlinkLinuxX64(type:Exec) { t ->
    configureJlink(t, "$linuxX64jdk", "$buildDir/jlink/linuxX64")
    doFirst {
        if (!hasLinuxX64Jdk()) {
            throw new InvalidUserDataException("$linuxX64jdk does not seem to be a linux x64 JDK, please set -Plinux-x64jdk=c:/path/to/jdk")
        }
    }
}

task jlinkLinuxAarch64(type:Exec) { t ->
    configureJlink(t, "$linuxAarch64jdk", "$buildDir/jlink/linuxAarch64")
    doFirst {
        if (!hasLinuxAarch64Jdk()) {
            throw new InvalidUserDataException("$linuxAarch64jdk does not seem to be a linux aarch64 JDK, please set -Plinux-aarch64jdk=c:/path/to/jdk")
        }
    }
}

task jlinkWinX64(type:Exec) { t ->
    configureJlink(t, "$winX64jdk", "$buildDir/jlink/winX64")
    doFirst {
        if (!hasWinX64Jdk()) {
            throw new InvalidUserDataException("$winX64jdk does not seem to be a windows JDK, please set -Pwin-x64jdk=/path/to/jdk")
        }
    }

    doLast {
        String base = new File("$buildDir/jlink/winX64/jre").getPath();
        fileTree("$buildDir/jlink/winX64/jre").matching {
            include "**/*.exe"
            include "**/*.dll"
        }.each {
            String rel = it.getPath().substring(base.length() + 1);
            File src = new File("$winX64jdk", rel);
            
            if(src.exists()) {
                java.nio.file.Files.copy(src.toPath(), it.toPath(), java.nio.file.StandardCopyOption.REPLACE_EXISTING);
            }
        }
    }
}

task jlinkAny() {
    if(org.gradle.internal.os.OperatingSystem.current().isLinux()) {
        if(isAarch64()) {
            dependsOn jlinkLinuxAarch64
        } else {
            dependsOn jlinkLinuxX64
        }
    } else if(org.gradle.internal.os.OperatingSystem.current().isWindows()) {
        dependsOn jlinkWinX64
    }
}

actualSubprojects*.test {
    dependsOn rootProject.tasks["jlinkAny"]
}

task release() {
    doFirst {
        if(version.contains('SNAPSHOT')) {
            throw new RuntimeException("Cannot release a SNAPSHOT: " + version);
        }

        if(!hasWinX64Jdk()) {
            throw new RuntimeException("Cannot release without a WINDOWS x64 JDK");
        }
        if(!hasLinuxX64Jdk()) {
            throw new RuntimeException("Cannot release without a LINUX x64 JDK");
        }
        if(!hasLinuxAarch64Jdk()) {
            throw new RuntimeException("Cannot release without a LINUX aarch64 JDK");
        }
    }
}

evaluationDependsOnChildren()
task jacocoFullReport(type: org.gradle.testing.jacoco.tasks.JacocoReport) {
    dependsOn actualSubprojects*.test

    getAdditionalSourceDirs().from(files(actualSubprojects.sourceSets.main.allSource.srcDirs))
    getSourceDirectories().from(files(actualSubprojects.sourceSets.main.allSource.srcDirs))
    getClassDirectories().from(files(actualSubprojects.sourceSets.main.output))

    rootProject.getAllTasks(true).each { p, tasks ->
        if(p.name == 'interfaces' || p.name == 'launcher' || p.name == 'ui' || p.name == 'api' || p.name == 'logging') {
            return; // no tests run in there right now.
        }

        tasks.each {
            if(!it.enabled) {
                return;
            }
            def x = it.getExtensions().findByType(org.gradle.testing.jacoco.plugins.JacocoTaskExtension);
            if(x != null) {
                getExecutionData().from(x.destinationFile);
            }
        }
    }

    reports {
        xml.required = true
        xml.destination file("$buildDir/reports/jacoco/jacocoFullReport/jacocoFullReport.xml")
    }

    onlyIf = {
        true
    }
}

task test {
    dependsOn actualSubprojects*.test
    finalizedBy testReport
    finalizedBy jacocoFullReport
}

sonarqube {
    properties {
        property "sonar.projectKey", "bdeployteam_bdeploy"
        property "sonar.coverage.jacoco.xmlReportPaths", "$buildDir/reports/jacoco/jacocoFullReport/jacocoFullReport.xml"
        property "sonar.verbose", "true"
        property "sonar.host.url", "https://sonarcloud.io"
        property "sonar.organization", "bdeployteam"
    }
}

project.tasks["sonarqube"].dependsOn build
project.tasks["sonarqube"].dependsOn jacocoFullReport

build.dependsOn test

if (org.gradle.internal.os.OperatingSystem.current().isLinux()) {
    if(isAarch64()) {
        if(!hasLinuxX64Jdk()) {
            logger.warn("No linux x64 JDK available, skipping linux x64 distribution")
            jlinkLinuxX64.enabled = false
        }
    } else {
        if(!hasLinuxAarch64Jdk()) {
            logger.warn("No linux aarch64 JDK available, skipping linux aarch64 distribution")
            jlinkLinuxAarch64.enabled = false
        }
    }
    // need special JDK for win64 as module input dir
    if(!hasWinX64Jdk()) {
        logger.warn("No windows x64 JDK available, skipping windows x64 distribution")
        jlinkWinX64.enabled = false
    }
} else if (org.gradle.internal.os.OperatingSystem.current().isWindows()) {
    // need special JDK for linux64 as module input dir
    if(!hasLinuxX64Jdk()) {
        logger.warn("No linux x64 JDK available, skipping linux x64 distribution")
        jlinkLinuxX64.enabled = false
    }
    if(!hasLinuxAarch64Jdk()) {
        logger.warn("No linux aarch64 JDK available, skipping linux aarch64 distribution")
        jlinkLinuxAarch64.enabled = false
    }
}

