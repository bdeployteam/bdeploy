import com.github.psxpaul.task.JavaExecFork
import okhttp3.OkHttpClient
import org.gradle.api.internal.tasks.userinput.UserInputHandler

import java.util.concurrent.TimeUnit

plugins {
    id 'base'
    id "com.github.psxpaul.execfork" version "0.2.2"
    id "jacoco"
    id "com.github.breadmoirai.github-release" version "2.5.2"
}

ext {
    testServerRoot = layout.buildDirectory.dir("test-root").get().asFile
    testServerHost = "localhost"
    testServerPort = 7711

    testServerRootCentral = layout.buildDirectory.dir("test-root-central").get().asFile
    testServerRootManaged = layout.buildDirectory.dir("test-root-managed").get().asFile
    testServerPortCentral = 7715
    testServerPortManaged = 7716
}

evaluationDependsOn(':minion')

static int randomServerPort() {
    new ServerSocket(0).withCloseable {
        return it.getLocalPort();
    }
}

void createProductTasks(String taskName, String prod) {
    tasks.register("${taskName}", Zip) {
        from fileTree(dir: "${projectDir}/${prod}")
        archiveFileName = "${prod}-direct.zip"
        destinationDirectory = layout.buildDirectory.dir("distribution")
        inputs.dir file("${projectDir}/${prod}")
    }

    build {
        dependsOn "${taskName}"
    }
}

void setupBDeployEnv(ProcessForkOptions options, String root) {
    options.environment += [
        HOSTNAME: testServerHost,
        BDEPLOY_ROOT: root,
    ]
}

void setupBDeployRemoteEnv(ProcessForkOptions options, String root, int port) {
    setupBDeployEnv(options, root)
    options.environment += [
        BDEPLOY_REMOTE: "https://localhost:${port}/api",
        BDEPLOY_TOKENFILE: "${root}/test-token.txt",
        REMOTE_BHIVE: "Test"
    ]
}

void setupBDeployJavaExec(JavaExec je, String root, int port) {
    je.mainClass = project(":minion").application.getMainClass().get()
    je.classpath = project(":minion").sourceSets.main.runtimeClasspath
    if(root != null) {
        setupBDeployRemoteEnv(je, root, port)
    }
}

void setupProfilerAgent(JavaExecFork je, String name) {
    if(project.hasProperty("yourkitPath") && !rootProject.isAarch64()) {
        def path = new File(project.getProperty("yourkitPath"));
        def profPath = null;

        if (org.gradle.internal.os.OperatingSystem.current().isWindows()) {
            profPath = new File(path, "bin/windows-x86-64/yjpagent.dll");
        } else if (org.gradle.internal.os.OperatingSystem.current().isLinux()) {
            profPath = new File(path, "bin/linux-x86-64/libyjpagent.so");
        }

        je.jvmArgs += [ "-agentpath:" + profPath + "=tracing,sessionname=" + name ];
    }
}

tasks.register('triggerStopBDeploy') {
    doLast {
        tasks.named('startTestBDeploy').get().stop();
        tasks.named('startTestBDeployManaged').get().stop();
        tasks.named('startTestBDeployCentral').get().stop();

        println("Stopped BDeploy Server")
    }
}

void createServerTasks(String name, String root, int port) {
    tasks.register("initTestBDeploy${name}", JavaExec) {
        setupBDeployJavaExec(it, root, port);

        def taskName = "";
        if (org.gradle.internal.os.OperatingSystem.current().isWindows()) {
            taskName = "winX64DistZip"
        } else if (org.gradle.internal.os.OperatingSystem.current().isLinux()) {
            if (rootProject.isAarch64()) {
                taskName = "linuxAarch64DistZip"
            } else {
                taskName = "linuxX64DistZip"
            }
        }
        dependsOn ':minion:' + taskName

        doFirst() {
            delete "${root}"
        }

        if (name.equals("Central") || name.equals("Managed")) {
            // save some time on startup...
            args = ["init", "--port=${port}", "--dist=ignore", "--mode=" + name, "--initUser=admin", "--initPassword=adminadminadmin"]
        } else {
            def poolDir = layout.buildDirectory.dir('test-pool').get().asFile
            args = ["init", "--port=${port}", "--dist=" + project(':minion').tasks.named(taskName).get().outputs.files[0], "--mode=standalone", "--initUser=admin", "--initPassword=adminadminadmin", "--pooling", "--pool=${poolDir}"]
        }

        mustRunAfter("externalSoftwareZip")
        mustRunAfter("externalSoftware2Zip")
        mustRunAfter("product1Zip")
        mustRunAfter("product2Zip")
        mustRunAfter("product3Zip")
    }

    tasks.register("startTestBDeploy${name}", JavaExecFork) {
        dependsOn "initTestBDeploy${name}"

        doNotTrackState("No State")
        setupBDeployEnv(it, root)
        setupProfilerAgent(it, "Test" + name)
        main = project(":minion").application.getMainClass().get()
        classpath = project(":minion").sourceSets.main.runtimeClasspath
        args = [ "start", "--allowCors", "--consoleLog" ]
        jvmArgs += [ '-Xmx128M' ] // all tests must fit :)
        waitForPort = port

        mustRunAfter("initTestBDeploy${name}")
    }
}

createServerTasks("", testServerRoot.toString(), testServerPort);
tasks.register('checkTestBDeploy', JavaExec) {
    dependsOn startTestBDeploy
    setupBDeployJavaExec(it, testServerRoot.toString(), testServerPort);
    args = ["remote-master", "--minions"]

    mustRunAfter(startTestBDeploy)
}

createServerTasks("Central", testServerRootCentral.toString(), testServerPortCentral);
createServerTasks("Managed", testServerRootManaged.toString(), testServerPortManaged);

startTestBDeployManaged.mustRunAfter(checkTestBDeploy)
startTestBDeployCentral.mustRunAfter(startTestBDeployManaged)


tasks.register('cleanExternalSoftwareHive', Delete) {
    delete layout.buildDirectory.dir("external-software-hive")
}

tasks.register('initExtSoftwareHive', JavaExec) {
    dependsOn cleanExternalSoftwareHive
    setupBDeployJavaExec(it, testServerRoot.toString(), testServerPort);
    args = ["bhive", "init", "--hive=${layout.buildDirectory.dir('external-software-hive').get().asFile}"]
}

// now define the dynamic tasks for each operating system
createExternalSoftwareTasks("windows")
createExternalSoftwareTasks("linux")

void createExternalSoftwareTasks(String os) {
    def osUpper = os.substring(0,1).toUpperCase() + os.substring(1);
    def hive = layout.buildDirectory.dir("external-software-hive").get().asFile;
    def source = "${projectDir}/external-software/${os}"

    tasks.register("externalSoftware${osUpper}", JavaExec) {
        dependsOn "initExtSoftwareHive"
        setupBDeployJavaExec(it, testServerRoot.toString(), testServerPort);
        args = ["bhive", "import", "--hive=${hive}", "--source=${source}", "--manifest=external/software/${os}:v1.0.0"]
    }

    build {
        dependsOn "externalSoftware${osUpper}"
    }
}

tasks.register('externalSoftwareZip', Zip) {
    dependsOn externalSoftwareWindows
    dependsOn externalSoftwareLinux
    archiveFileName = "external-software-hive.zip"
    destinationDirectory = layout.buildDirectory.dir("distribution")

    from layout.buildDirectory.dir("external-software-hive")
}

// now define the dynamic tasks for each product
createProductTasks("product1Zip", "test-product-1")
createProductTasks("product2Zip", "test-product-2")
createProductTasks("product3Zip", "chat-product-1")
createProductTasks("externalSoftware2Zip","external-software-2-raw")

tasks.register('verifyBDeployExe', JavaExec) {
    setupBDeployJavaExec(it, null, 0);
    args = ["verify-signature", "--executable=" + project(":launcher").projectDir + "/src/winX64/dist/BDeploy.exe"]
}

tasks.register('verifyFileAssocExe', JavaExec) {
    setupBDeployJavaExec(it, null, 0);
    args = ["verify-signature", "--executable=" + project(":launcher").projectDir + "/src/winX64/dist/FileAssoc.exe"]
}

tasks.register('verifyInstallerBin', JavaExec) {
    setupBDeployJavaExec(it, null, 0);
    args = ["verify-signature", "--executable=" + project(":launcher").projectDir + "/src/winX64/dist/bin/Installer.bin"]
}

tasks.register('verifyBinaries') {
    dependsOn verifyBDeployExe
    dependsOn verifyFileAssocExe
    dependsOn verifyInstallerBin
}

tasks.register('release') {
    dependsOn verifyBinaries
    doLast {
        println "Release seems to do be ok..."
    }
}

evaluationDependsOn(':api')
githubRelease {
    if(project.hasProperty('githubToken')) {
        token = project.getProperty('githubToken')
    }
    owner = "bdeployteam"
    repo = "bdeploy"
    tagName = "v${version}"
    releaseName = "Release ${version}"
    targetCommitish = "master"

    releaseAssets.from(project(":minion").linuxX64DistZip)
    releaseAssets.from(project(":minion").linuxAarch64DistZip)
    releaseAssets.from(project(":minion").winX64DistZip)
    releaseAssets.from(project(":api").shadowJar)
    releaseAssets.from(fileTree(project(":api").resolve.outputDir))
    releaseAssets.from(project(":test-data").product1Zip)
    releaseAssets.from(project(":test-data").product2Zip)
    releaseAssets.from(project(":test-data").product3Zip)

    // increase read and write timeouts as the files are rather large :)
    client new OkHttpClient.Builder().readTimeout(10, TimeUnit.MINUTES).writeTimeout(10, TimeUnit.MINUTES).build();
}

// coverage for the rest of the tasks
jacoco {
    applyTo initTestBDeploy
    applyTo checkTestBDeploy
    if(!project.hasProperty('yourkitPath')) {
        applyTo startTestBDeploy
        applyTo startTestBDeployCentral
        applyTo startTestBDeployManaged
    }
}

// now all tasks that depend on any of the generated tasks
tasks.register('setupDemoServer') {
    dependsOn checkTestBDeploy
    dependsOn startTestBDeployCentral
    dependsOn startTestBDeployManaged

    doFirst() {
        println("----------------------------------------------------------------------------------------")
        println("Successfully started demo server. Point your browser to:")
        println("  https://localhost:${testServerPort} - STANDALONE Demo Server")
        println("  https://localhost:${testServerPortCentral} - CENTRAL Demo Server")
        println("  https://localhost:${testServerPortManaged} - MANAGED Demo Server")
        println("User and password for the demo server(s) are 'admin' and 'admin'.")
        println("NOTE: that cookies are hostname based, so logging in to one will log out on any other");
        println("      server running on the same hostname.");
        println("----------------------------------------------------------------------------------------")
    }
}

tasks.register('runDemoServer') {
    dependsOn setupDemoServer
    doLast() {
        // no println will work in doLast, it will appear only AFTER the question is answered.
        def userInput = services.get(UserInputHandler)
        def answer = userInput.askUser(i -> i.askQuestion("Enter any value (or press enter) to stop the server", "Stop")).getOrNull();
    }
}

